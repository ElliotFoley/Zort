File sorting challenge:

The objective of this program is to re-sort files which are out of their correct ordered format. You can use the POSIX library to do file handling in most Linux distros if you would like to do this in C/C++. Alternatively, if you would like to use Python, it's probably just like one line directory.sort('read_my_mind') or some garbage like that.

Objective 0 (optional): List all the files names in the current directory (this is just for practice with reading the file names).

There are two types of files that might appear: ones in the proper format which are sortable files, and ones which are in the incorrect format which are considered unsortable. A sortable file has a few parts to it which are, in order: a category, which is a series of uppercase and/or lowercase characters of length no more than 10; an index, which is a series of number characters of length no more than 5; an optional subindex, which is a period followed by another series of number characters of length no more than 5; lastly a file extension, like .mp4, .jpeg, .gif, or more generally, a period followed by a series of uppercase and/or lowercase letters and/or numbers. If you would like, here is a Regex string to recognize the format without any limits: "[a-zA-Z]+[0-9]+(\.[0-9]+)?\.[a-zA-Z0-9]+", and here is one which recognizes the maximum reasonable character limits: "[a-zA-Z]{1,10}[0-9]{1,5}(\.[0-9]{1,5})?\.[a-zA-Z0-9]+".

Objective 1: Distinguish between sortable files and unsortable files. Print out a list of all the unsortable files, then print out a list of all of the sortable files (any order).

For the sortable files, they are supposed to go in a specific order. The index is supposed to be unique per category - S3.jpg and S3.png coexisting is accepted by Linux but this is not acceptable for the sorting system. However, S3.jpg and G3.jpg coexisting is fine, since they are of different categories. Items with the optional subindex take up the same index spot - S3.0.jpg and S3.png should not coexist. However, items with a subindexes can share an index with each other (think of them like fractions of an index). So SB3.0.jpg and SB3.1.png are fine to coexist. However, they cannot share their subindexes per index: SB3.0.png and SB3.0.jpg conflict with each other. Indexes should not have holes per category: if an SRV2 does not exist, but an SRV3 does exist, then there is a hole at least at SRV2.

Objective 2: Look at all the sortable files and report if there is a confliction error (an index or subindex with too many files claiming it) and list the offending filenames. If there is no confliction error, report if there is a hole error and report which category and index are missing. If there are no confliction errors and no hole errors, print that the state of the folder is acceptable.

If there are only hole errors, these can be fixed. Take the higher indexes and rename them with POSIX to fill in the holes. Do not change the file extensions while doing so, only change the index. When renaming a file index with multiple subindexes, make rename all of them to the same index: renaming S301.0, S301.1, and S301.2 to index 6 would give S6.0, S6.1, and S6.2, maintaining the same file extensions they had.

Objective 3: Fix the hole errors in a reasonable runtime complexity (preferably less than O(n^2)). Do so while maintaining the unsortable files and the categories and extensions of each file, and do not operate on cases where there is a confliction error. The output should then report no errors for the Objective 2 code.